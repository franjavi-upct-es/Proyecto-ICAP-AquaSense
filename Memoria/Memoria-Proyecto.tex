\documentclass[10pt]{article}
\usepackage{setspace}
\usepackage{enumitem}
\usepackage{fullpage}
\usepackage{inputenc, fontenc}
\usepackage{hyperref}
\usepackage[a4paper, left=2cm, right=2cm, top=2cm, bottom=1.5cm]{geometry}
\setstretch{1.3}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{array}
\usepackage{listings}
\usepackage{emoji}
\lstset{
	language=Python,
	basicstyle=\ttfamily\small,
	numberstyle=\tiny,
	keywordstyle=\color{blue},
	commentstyle=\color{olive},
	stringstyle=\color{red},
	breakatwhitespace=false, 
	breaklines=true,
	showspaces=false,
	showstringspaces=false,
	showtabs=false, 
	tabsize=2,
	literate={á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1{ñ}{{\~n}}1 {Á}{{\'A}}1 {Í}{{\'I}}1 {Ú}{{\'U}}1 {¿}{{\textexclamdown}}1,
	mathescape=false,
	backgroundcolor=\color{lightgray!10}
}
\lstdefinelanguage{yaml}{
  keywords={true,false,null,y,n},
  keywordstyle=\color{blue}\bfseries,
  basicstyle=\ttfamily\small,
  sensitive=false,
  comment=[l]{\#},
  morecomment=[l]{\#},
  morestring=[b]',
  morestring=[b]",
  showstringspaces=false,
  breaklines=true,
  columns=fullflexible
}
\lstdefinelanguage{docker}{
  keywords={true,false,null,y,n},
  keywordstyle=\color{blue}\bfseries,
  basicstyle=\ttfamily\small,
  sensitive=false,
  comment=[l]{\#},
  morecomment=[l]{\#},
  morestring=[b]',
  morestring=[b]",
  showstringspaces=false,
  breaklines=true,
  columns=fullflexible
}
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}
\renewcommand*\contentsname{\color{black}Índice} 
\title{Infraestructura para la Computación de Altas Prestaciones\\Proyecto Final: AquaSenseCloud}
\author{Francisco Javier Mercader Martínez\\Javier Moreno Pagán\\Pablo Meseguer Domenech}
\date{Curso: 2024/2025}

\begin{document}
\maketitle
\tableofcontents
\newpage
\section{Cronograma}
\begin{longtable}{|p{2.5cm}|p{9cm}|p{3cm}|p{2cm}|}
	\hline
	\textbf{Fecha}       & \textbf{Tarea}                                                                                                                                                                                                                               & \textbf{Responsable} & \textbf{Duración} \\
	\hline
	\endhead

	% SEMANA 1
	11 de noviembre      & \textbf{Inicio y Diseño de Arquitectura:} Definición de requisitos, análisis del dataset CSV y diseño de la arquitectura completa en AWS y endpoints de la API.                                                                              & Todo el Equipo       & 1 día             \\
	\hline
	12-13 de noviembre   & \textbf{Infraestructura de Red Base:} Creación de VPC, subnets, Security Groups, bucket S3 para datos crudos y tablas en DynamoDB.                                                                                                           & Javier Moreno        & 2 días            \\
	\hline
	14-15 de noviembre   & \textbf{Lógica de Negocio y Pipeline:} Desarrollo de funciones Lambda para procesamiento de CSV y cálculos estadísticos (maxdiff, temp mensual).                                                                                             & Pablo Meseguer       & 2 días            \\
	\hline
	16-17 de noviembre   & \textbf{Configuración API Base:} Configuración del API Gateway y desarrollo de Lambdas para endpoints REST básicos (/sd, /temp).                                                                                                             & Fco. Jav. Mercader   & 2 días            \\
	\hline

	% SEMANA 2
	18-19 de noviembre   & \textbf{Seguridad y Automatización:} Configuración de roles IAM, políticas de seguridad y creación de plantillas CloudFormation base (IaC).                                                                                                  & Javier Moreno        & 2 días            \\
	\hline
	20-21 de noviembre   & \textbf{Sistema de Alarmas:} Configuración de SNS Topic, integración de alertas por desviación de datos y pruebas de envío de emails.                                                                                                        & Pablo Meseguer       & 2 días            \\
	\hline
	22-24 de noviembre   & \textbf{Integración y Pruebas:} Integración de todas las Lambdas con DynamoDB, manejo de errores en API y creación de suite de pruebas en Postman.                                                                                           & Fco. Jav. Mercader   & 3 días            \\
	\hline

	% SEMANA 3
	25-26 de noviembre   & \textbf{Dockerización:} Creación de Dockerfile optimizado para la API, construcción de imagen y subida al repositorio ECR.                                                                                                                   & Pablo Meseguer       & 2 días            \\
	\hline
	27-28 de noviembre   & \textbf{Infraestructura Avanzada (ECS sobre EC2):} Configuración de Application Load Balancer (ALB), Target Groups y Listener, creación del clúster ECS (\textbf{\texttt{Launch Type: EC2}}), Task Definition EC2 y ECS Service.             & Javier Moreno        & 2 días            \\
	\hline
	29 de nov - 1 de dic & \textbf{Escalabilidad (capacidad EC2):} Configuración de ECSLaunchConfiguration y ECSAutoScalingGroup (\texttt{\textbf{MinSize=2, MaxSize=5, DesiredCapacity=3}}) como capacidad del clúster ECS, y validación de funcionamiento bajo carga. & Fco. Jav. Mercader   & 3 días            \\
	\hline

	% SEMANA 4
	2 de diciembre       & \textbf{Documentación Técnica:} Redacción de la memoria técnica, diagramas finales de arquitectura y justificación de decisiones.                                                                                                            & Javier Moreno        & 1 día             \\
	\hline
	3 de diciembre       & \textbf{Manual de Replicación:} Elaboración de guía paso a paso para replicar el despliegue y scripts de limpieza de recursos.                                                                                                               & Pablo Meseguer       & 1 día             \\
	\hline
	4 de diciembre       & \textbf{Pruebas Finales y Despliegue:} Despliegue final limpio en cuentas AWS Academy y validación "End-to-End" de todo el flujo.                                                                                                            & Todo el Equipo       & 1 día             \\
	\hline
	5 de diciembre       & \textbf{Entrega Final:} Recopilación de entregables, preparación de material de defensa y envío del proyecto.                                                                                                                                & Todo el Equipo       & 1 día             \\
	\hline
\end{longtable}

\section{Diagrama Arquitectura de la solución}
\begin{center}
	\includegraphics[width=0.7\textwidth]{estructuras/Estructura AWS}
\end{center}

\newpage
\section{Listado de Recursos y Servicios con su funcionalidad}
\begin{enumerate}[label=\textbf{\arabic*.}]
	\item \textbf{Ingesta y almacenamiento}
	      \begin{itemize}[label=\textbullet]
		      \item \textbf{Amazon S3 (AWS::S3::Bucket):} La arquitectura utiliza dos buckets con propósitos diferenciados:
		            \begin{itemize}[label=$-$]
			            \item \textbf{Bucket de Datos (proy-marmenor-csv-raw):} Almacena los archivos CSV de datos brutos con las medias y desviaciones típicas de temperaturas. Actúa como el punto de entrada del pipeline, donde la carga de un nuevo archivo desencadena automáticamente la ejecución de la función Lambda.
			            \item \textbf{Bucket de Código (proy-marmenor-codebucket):} Repositorio de soporte utilizado para almacenar el código fuente comprimido (\texttt{.zip}) de la función Lambda y otros artefactos necesarios para el despliegue automatizado de la infraestructura mediante CloudFormation.
		            \end{itemize}
	      \end{itemize}
	\item \textbf{Pipeline de datos}
	      \begin{itemize}[label=\textbullet]
		      \item \textbf{AWS Lambda (AWS::Lambda::Function):} Ejecuta funciones que procesan los archivos almacenados en S3, transformando dichos datos y cargándolos en una tabla DynamoDB. Esos datos almacenados en la tabla ya están preparados para ser consultados.
		      \item \textbf{Amazon SNS (AWS::SNS::Topic):} Se utiliza para enviar notificaciones cuando la desviación estándar semanal de las temperaturas supera el umbral de 0.5. Esta modificación se publica en el tema SNS, informando a los suscriptores (en este caso los analistas) sobre la situación crítica en el monitoreo de temperaturas.
	      \end{itemize}
	\item \textbf{Almacenamiento de datos procesados/transformados}
	      \begin{itemize}[label=\textbullet]
		      \item \textbf{DynamoDB (AWS::DynamoDB::Table):} Almacena todos los datos transformados y procesados, listos para ser consultados, proporcionando así un acceso rápido y escalable a los datos.
	      \end{itemize}
	\item \textbf{Recursos para el desarrollo y pruebas iniciales}
	      \begin{itemize}[label=\textbullet]
		      \item \textbf{Instancia EC2 (AWS::EC2::Instance):} Utilizada para desarrollar, probar y ajustar el contenedor con la aplicación AquaSense. En esta instancia se configuró el entorno de Docker y se realizaron pruebas locales antes de enviar la imagen al repositorio de ECR.
	      \end{itemize}
	\item\textbf{ Infraestructura de red y conectividad}
	      \begin{itemize}[label=\textbullet]
		      \item \textbf{VPC (AWS::EC2::VPC):} Proporciona un entorno de red aislado donde se despliegan los recursos de la infraestructura.

		      \item \textbf{Subnets (AWS::EC2::Subnet):} Se crean 2 subredes públicas y 2 subredes privadas distribuidas en distintas Availability Zones. Las subredes públicas alojan los componentes de entrada/salida a Internet (p. ej., NAT Gateway) y las privadas alojan los recursos de cómputo internos (ECS sobre EC2 y tareas en modo awsvpc).

		      \item \textbf{Internet Gateway (AWS::EC2::InternetGateway):} Conecta la VPC con Internet, permitiendo la exposición del ALB.

		      \item \textbf{NAT Gateway (AWS::EC2::NatGateway):} Proporciona salida a Internet a los recursos ubicados en subredes privadas sin exponerlos directamente. Se ubica en una subred pública y se utiliza como ruta por defecto (0.0.0.0/0) desde la tabla de rutas privada.

		      \item \textbf{Route Table (AWS::EC2::RouteTable):} Define las rutas de tráfico dentro de la VPC. Incluye una tabla pública con salida al Internet Gateway y una tabla privada con salida al NAT Gateway, asociadas a sus respectivas subredes.
	      \end{itemize}
	\item \textbf{Almacenamiento de imágenes}
	      \begin{itemize}[label=\textbullet]
		      \item \textbf{ECR (Amazon Elastic Container Registry):} Repositorio para almacenar y versionar la imagen del contenedor de AquaSense después de desarrollarla en EC2. Este recurso nos facilita la integración con ECS para el despliegue en producción de nuestra aplicación.
	      \end{itemize}
	\item \textbf{Recursos para el despliegue de la aplicación}
	      \begin{itemize}[label=\textbullet]
		      \item \textbf{ECSCluster (AWS::ECS::Cluster):} Agrupa, administra y organiza todas las tareas y servicios relacionados con la ejecución del contenedor de la aplicación. Actúa como punto central de administración para la ejecución de tareas, asegurando que estas puedan desplegarse de manera distribuida y eficiente.
		      \item \textbf{ALB (AWS::ElasticLoadBalancingV2::LoadBalancer):} Balanceador de carga que gestiona/balancea el tráfico de los analistas hacia las tareas ECS. Redirige las solicitudes desde el puerto 80 (tráfico HTTP) al puerto 5000 del contenedor, además, mejora la disponibilidad y la tolerancia a fallos de nuestra aplicación.
		      \item \textbf{ALBListener (AWS::ElasticLoadBalancingV2::Listener):} Configura reglas en el balanceador de carga para redirigir las solicitudes hacia el grupo de destino, escucha el tráfico de los analistas a través del puerto 80.
		      \item \textbf{ECSTargetGroup (AWS::ElasticLoadBalancingV2::TargetGroup):} Asocia las tareas ECS con el balanceador de carga y configura verificaciones de estado mediante el endpoint \textbf{\texttt{/health}} que ha ido configurado en nuestra aplicación. Este permite conocer el estado en que se encuentra las tareas para que, en caso de que alguan falle, se marca la tarea como no saludable y eso informa al ECS Service de que hay que lanzar nuevas tareas para mantener su número deseado.
	      \end{itemize}
	\item \textbf{Definición y gestión de tareas}
	      \begin{itemize}[label=\textbullet]
		      \item \textbf{ECSTaskDefinition (AWS::ECS::TaskDefinition):} Describe la definición de tarea para ejecutar el contenedor en ECS con compatibilidad EC2 (RequiresCompatibilities: EC2) y modo de red awsvpc. Especifica la imagen del contenedor en ECR, los recursos asignados (CPU y memoria), el mapeo de puertos (ContainerPort: 8080) y los roles (ExecutionRoleArn y TaskRoleArn). Es la plantilla base a partir de la cual ECS lanza las tareas.

		      \item \textbf{ECSService (AWS::ECS::Service):} Administra la ejecución continua del número deseado de tareas (DesiredCount: 3) a partir de la Task Definition anterior, usando LaunchType: EC2. Integra el servicio con el ALB mediante el Target Group, y ejecuta las tareas en subredes privadas (AssignPublicIp: DISABLED) con los Security Groups importados del stack de red. La disponibilidad real del servicio depende de la capacidad aportada por el Auto Scaling Group de instancias EC2.
	      \end{itemize}
	\item \textbf{Escalado automático}
	      \begin{itemize}[label=\textbullet]
		      \item \textbf{ECSLaunchConfiguration (AWS::AutoScaling::LaunchConfiguration):} Define la configuración de las instancias EC2 que aportan capacidad al clúster ECS (AMI optimizada de ECS, tipo de instancia, Security Groups e Instance Profile). Incluye UserData para registrar automáticamente la instancia en el clúster ECS (\texttt{ECS\_CLUSTER=...}).

		      \item \textbf{ECSAutoScalingGroup (AWS::AutoScaling::AutoScalingGroup):} Proporciona la capacidad de cómputo al clúster ECS mediante un grupo de instancias EC2 desplegadas en subredes privadas. Se configura con MinSize=2, MaxSize=5 y DesiredCapacity=3. En este proyecto el escalado se realiza a nivel de instancias (capacidad del clúster), no a nivel de tareas mediante Application Auto Scaling.
	      \end{itemize}
	\item \textbf{Seguridad}
	      \begin{itemize}[label=\textbullet]
		      \item \textbf{ALB Security Group (AWS::EC2::SecurityGroup):} Permite el acceso al balanceador de carga desde Internet (a través del puerto 80-HTTP), asegurando que el tráfico pueda alcanzar la aplicación.
		      \item \textbf{Task Security Group (AWS::EC2::SecurityGroup):} Permite el tráfico del ALB a las tareas de ECS (a través del puerto 5000), asegurando que las solicitudes lleguen al contenedor de la aplicación de manera distribuida y segura.
	      \end{itemize}
	\item \textbf{Gestión e implementación}
	      \begin{itemize}[label=\textbullet]
		      \item \textbf{CloudFormation:} Automatiza el despliegue de la infraestructura mediante plantillas asegurando la coherencia y la reproducibilidad en la implementación.
		      \item \textbf{AWS CLI:} Utilizada para el desarrollo de la imagen y autenticación de recursos a la hora de subir la imagen del contenedor de nuestra aplicación a AWS ECR.
		      \item \textbf{Docker:} Facilita el desarrollo y la contenedorización de la aplicación, asegurando un entorno de ejecución consistente.
		      \item \textbf{IAM Roles (AWS::IAM::Role):} Proporcionan los permisos necesarios para que las tareas de ECS accedan a DynamoDB y otros recursos de AWS. Permite que los distintos recursos de la arquitectura desplegada se puedan comunicar entre sí con seguridad.
	      \end{itemize}
\end{enumerate}

\pagebreak

\section{Ejemplos de demostración de correcta funcionalidad}
\begin{itemize}[label=\textbullet]
	\item \textbf{Función Lambda:}

	      \begin{center}
		      \includegraphics[width=\textwidth]{imgs/screenshot001}
	      \end{center}

	      \begin{figure}[h]
		      \centering
		      \includegraphics[width=0.5\linewidth]{imgs/screenshot002}
		      \caption{Contenido del fichero: "\texttt{\textbf{temperatura\_1.csv}}"}
		      \label{fig:screenshot002}
	      \end{figure}

	      \pagebreak

	      \begin{figure}
		      \centering
		      \includegraphics[width=\linewidth]{imgs/screenshot004}
		      \caption{Almacenamiento de datos transformados en DynamoDB}
		      \label{fig:screenshot004}
	      \end{figure}

	      \underline{\textbf{Nota:}} Observar que la función lambda trata con la posibilidad de ingesta de datos sin importar los siguientes factores: su orden temporal, su repetición y datos mensuales separados en distintos ficheros.

	      \textbf{Comentar también que los datos transformados se almacenan en la tabla de DynamoDB correctamente si se realiza la ingesta de manera controlada y con ficheros de un tamaño medio (2-3 Kbytes) como los utilizados en las pruebas realizadas.}

	      \begin{figure}[h]
		      \centering
		      \includegraphics[width=0.8\linewidth]{imgs/screenshot003}
		      \caption{Envío de correo a los analistas mediante un tópico definido mediante AWS SNS}
	      \end{figure}


	\item \textbf{ECR:}

	      \begin{center}
		      \includegraphics[width=\linewidth]{imgs/screenshot005}

	      \end{center}


	\item \textbf{Automatización del aprovisionamiento de la infraestructura mediante CloudFormation:}

	      \begin{center}
		      \includegraphics[width=\linewidth]{imgs/screenshot006}\\
		      \includegraphics[width=\linewidth]{imgs/screenshot007}\\
		      \includegraphics[width=\linewidth]{imgs/screenshot008}\\
	      \end{center}

	\item \textbf{Funcionamiento de la aplicación:}

	      Distintas consultas que pueden realizar los analistas a través del servidor web desplegado por las tareas. En la propia URL definen el tipo de dato a consultar con su mes y año específico, además del correcto funcionamiento de la aplicación con el endpoint \textbf{\texttt{/health}}.
	      \pagebreak
	      \begin{center}
		      \textbf{\texttt{health/}}

		      \includegraphics[width=\linewidth]{imgs/screenshot009}\\

		      \textbf{\texttt{maxdiff/}}

		      \includegraphics[width=\linewidth]{imgs/screenshot010}\\

		      \textbf{\texttt{months/}}

		      \includegraphics[width=\linewidth]{imgs/screenshot011}\\

		      \textbf{\texttt{sd/}}

		      \includegraphics[width=\linewidth]{imgs/screenshot012}\\

		      \pagebreak

		      \textbf{\texttt{temp/}}

		      \includegraphics[width=\linewidth]{imgs/screenshot013}\\
	      \end{center}

\end{itemize}

\section{Pasos a seguir}
\subsection{Despliegue de la infraestructura}
\begin{itemize}[label=\textbullet]
	\item Paso 0 (Previo): Crear la clave (\textit{Key Pair}) "proy-marmenor"
	      \begin{enumerate}
		      Acciones :
		      \item Ir a la consola de AWS $\rightarrow$ EC2 $\rightarrow$ Network \& Security $\rightarrow$ Key Pairs.
		      \item Crear una nueva Key Pair con nombre: proy-marmenor.
		      \item Descargar el fichero (formato .pem) y guardarlo de forma segura.

		            \textbf{Nota:} debe crearse en la misma región donde se despliega la infraestructura (us-east-1). Si la clave no existe, la pila de CloudFormation que crea la instancia EC2 fallará.
	      \end{enumerate}
	\item Paso 1: Infraestructura Base
	      \begin{enumerate}
		      \item Acceder a la consola de CloudFormation.
		      \item Crear ua nueva pila con \textbf{\texttt{proy-infraestructura-soporte.yaml}}
		      \item Esperar cmpletado (crea: VPC, Subnets, S3, DynamoDB, EC2, SNS)
		      \item Verificar que la instancia EC2 haya subido la imagen a ECR.
	      \end{enumerate}
	\item Paso 2: Pipeline de Datos Lambda
	      \begin{enumerate}[label=\arabic*)]
		      \item Crear nueva pila con \textbf{\texttt{proy-lambda\_bucket.yaml}}
		      \item Configurar parámetros:
		            \begin{itemize}[label=\textbullet]
			            \item \textbf{Email}: Correo electrónico para notificaciones SNS, se debe confirmar la suscripción para recibir los mensajes de alerta.
			            \item \textbf{NetworkStackName:} \textbf{\texttt{proy-infraestructura-soporte}}
		            \end{itemize}
		      \item Esperar completado (crea: Lambda Bucket S3 raw, Topic SNS)
	      \end{enumerate}
	\item Paso 3: Clúster ECS y Aplicación
	      \begin{enumerate}
		      \item Crear nueva pila con \textbf{\texttt{proy-infraestructura-cluster.yaml}}
		      \item Configurar parámetro:
		            \begin{itemize}[label=\textbullet]
			            \item \textbf{NetworkStackName:} \textbf{\texttt{proy-infraestructura-soporte}}
		            \end{itemize}
		      \item Esperar completado (crea: ECS Cluster, ALB, Target Group, Service)
		      \item Anota la URL del ALB de los Outputs.
	      \end{enumerate}
\end{itemize}
\subsection{Carga de Datos y Verificación}
\subsubsection{Ingesta de Datos}
\begin{enumerate}
	\item Acceder al bucket S3: \textbf{\texttt{proy-marmenor-csv-raw-[ACCOUNT-ID]}}
	\item Subir archivos CSV de temperatura (formato requerido):
	      \begin{verbatim}
Fecha,Medias,Desviaciones
2017/03/22,16.784072875976562,0.28715428709983826
		  \end{verbatim}
	\item Verificar ejecución automática de Lambda en CloudWatch Logs.
	\item Confirmar datos en DynamoDB (table \textbf{\texttt{Measures}}).
\end{enumerate}

\subsubsection{Prueba de Endpoints}
Desde un navegador o herramienta como Postman/curl:

\begin{verbatim}
# Health Check
http://[ALB-DNS]/health

# Temperatura media
http://[ALB-DNS]/temp?month=3&year=2017

# Desviación estándar
http://[ALB-DNS]/sd?month=3&year=2017

# Diferencia máxima
http://[ALB-DNS]/maxdiff?month=4&year=2017

# Meses disponibles
http://[ALB-DNS]/months
\end{verbatim}

\subsection{Eliminación de la Infraestructura}

\textbf{Orden de eliminación (crítico para evitar errores):}

\begin{enumerate}
	\item Vaciar buckets S3:
	      \begin{itemize}
		      \item \texttt{proy-marmenor-csv-raw-[ACCOUNT-ID]}
		      \item \texttt{proy-marmenor-codebucket-[ACCOUNT-ID]}
	      \end{itemize}
	\item Eliminar imagen de ECR: \texttt{aquasense-api}
	\item Eliminar pilas CloudFormation en orden inverso:
	      \begin{enumerate}[label=\arabic*.]
		      \item \texttt{proy-infraestructura-cluster}
		      \item \texttt{proy-lambda\_bucket}
		      \item \texttt{proy-infraestructura-soporte}
	      \end{enumerate}
	\item Verificar eliminación de tabla DynamoDB
	\item Verificar eliminación de suscripciones SNS
\end{enumerate}

\textbf{Nota}: Esperar 2-3 minutos entre eliminaciones para evitar dependencias.
\section{Anexos}

\subsection{Anexo A - Código Fuente Completo}

\subsubsection{A.1 Función Lambda de Procesamiento}
\textbf{Archivo}: \texttt{funcion\_lambda.py}

\begin{itemize}
	\item \textbf{Propósito}: Procesa archivos CSV y actualiza DynamoDB
	\item \textbf{Características}:
	      \begin{itemize}
		      \item Procesamiento de múltiples archivos simultáneos
		      \item Detección y sobrescritura de duplicados
		      \item Ajuste automático de mes (días $\le 3\to$ mes anterior)
		      \item Envío de alertas SNS (desviación $>$ 0.5°C)
		      \item Cálculo de métricas mensuales agregadas
	      \end{itemize}
	\item \textbf{Triggers}: S3 ObjectCreated en \texttt{*.csv}
	\item \textbf{Runtime}: Python 3.11
	\item \textbf{Timeout}: 60 segundos
	\item \textbf{Memoria}: 256 MB
\end{itemize}

\lstinputlisting[language=Python, escapechar={\@}]{../Ingesta Datos y Pipeline/funcion_lambda.py}

\subsubsection{A.2 API REST - Servidor Web}
\textbf{Archivo}: \texttt{aquasense.py}

\begin{itemize}
	\item \textbf{Framework}: Flask 3.0.0
	\item \textbf{Endpoints implementados}: 6
	\item \textbf{Base de datos}: DynamoDB (tabla plana)
	\item \textbf{Puerto}: 8080
	\item \textbf{Health check}: \texttt{/health} (para ALB)
\end{itemize}

\lstinputlisting[language=Python]{../Servidor Web y Containers/aquasense.py}

\subsection{Anexo B - Plantillas de Infraestructura como Código}

\subsubsection{B.1 Infraestructura Base}
\textbf{Archivo}: \texttt{proy-infraestructura-soporte.yaml}

\textbf{Recursos creados}:
\begin{itemize}
	\item VPC (192.168.0.0/16)
	\item 2 Subnets públicas + 2 privadas
	\item Internet Gateway + NAT Gateway
	\item Security Groups (ALB, Instancias)
	\item Tabla DynamoDB: \texttt{Measures}
	\item Bucket S3: \texttt{proy-marmenor-codebucket}
	\item Instancia EC2 para construcción Docker
\end{itemize}

\lstinputlisting[language=yaml]{../Plantillas CloudFormation IaC/proy-infraestructura-soporte.yaml}

\subsubsection{B.2 Pipeline Lambda}
\textbf{Archivo}: \texttt{proy-lambda\_bucket.yaml}

\textbf{Recursos creados}:
\begin{itemize}
	\item Función Lambda: \texttt{proy-marmenor-process-csv}
	\item Bucket S3: \texttt{proy-marmenor-csv-raw}
	\item Topic SNS: \texttt{proy-marmenor-alerts}
	\item Permisos de invocación S3 $\rightarrow$ Lambda
\end{itemize}

\lstinputlisting[language=yaml]{../Plantillas CloudFormation IaC/proy-lambda_bucket.yaml}
\subsubsection{B.3 Clúster ECS}
\textbf{Archivo}: \texttt{proy-infraestructura-cluster.yaml}

\textbf{Recursos creados}:
\begin{itemize}
	\item ECS Cluster: \texttt{proy-marmenor-cluster}
	\item Application Load Balancer + Listener
	\item Target Group (Health check: \texttt{/health})
	\item Task Definition (awsvpc, 256 CPU, 256 RAM)
	\item ECS Service (Launch Type: EC2, DesiredCount: 3)
	\item Auto Scaling Group (min: 2, max: 5)
\end{itemize}

\lstinputlisting[language=yaml]{../Plantillas CloudFormation IaC/proy-infraestructura-cluster.yaml}
\subsection{Anexo C - Configuración Docker}

\subsubsection{C.1 Dockerfile}
\textbf{Archivo}: \texttt{Dockerfile.txt}

\textbf{Características}:
\begin{itemize}
	\item Imagen base: \texttt{python:3.11-slim}
	\item Servidor: Gunicorn (2 workers, 4 threads)
	\item Puerto expuesto: 8080
	\item Health check: curl a \texttt{/health} cada 30s
	\item Usuario no-root (appuser:1000)
\end{itemize}

\lstinputlisting[language=docker]{../Servidor Web y Containers/Dockerfile.txt}
\subsubsection{C.2 Script de Automatización}
\textbf{Archivo}: \texttt{docker\_setup.sh}

\textbf{Acciones}:
\begin{enumerate}
	\item Instalación y configuración de Docker
	\item Descarga de código desde GitHub
	\item Construcción de imagen Docker
	\item Creación de repositorio ECR
	\item Autenticación en ECR
	\item Push de imagen a ECR
	\item Descarga del código de la función Lambda (\texttt{funcion\_lambda.py}) y compresión en \texttt{lambda.zip}
	\item Subida de \texttt{lambda.zip} al bucket S3 de código (\texttt{proy-marmenor-codebucket-<ACCOUNT\_ID>}) para que CloudFormation pueda desplegar la Lambda
\end{enumerate}

\lstinputlisting[language=bash]{../Plantillas CloudFormation IaC/docker_setup.sh}
\subsection{Anexo D - Estructura de Datos}

\subsubsection{D.1 Formato CSV de Entrada}
\begin{verbatim}
Fecha,Medias,Desviaciones
2017/03/22,16.784072875976562,0.28715428709983826
2017/03/30,17.32989501953125,0.4037204384803772
\end{verbatim}

\textbf{Notas}:
\begin{itemize}
	\item Separador: coma (,)
	\item Encoding: UTF-8
	\item Formato fecha: YYYY/MM/DD o YYYY-MM-DD
	\item Headers obligatorios: Fecha, Medias, Desviaciones
\end{itemize}

\subsubsection{D.2 Esquema DynamoDB}
\textbf{Tabla}: \texttt{Measures}

\textbf{Estructura}:
\begin{itemize}
	\item \textbf{Partition Key}: \texttt{monthYear} (String, "YYYY-MM")
	\item \textbf{Atributos}:
	      \begin{itemize}
		      \item \texttt{max\_temp}: Decimal
		      \item \texttt{max\_sd}: Decimal
		      \item \texttt{mean\_temp}: Decimal
		      \item \texttt{max\_diff\_temp}: Decimal
		      \item \texttt{mean\_temp\_count}: Number
		      \item \texttt{last\_updated}: String (ISO 8601)
	      \end{itemize}
\end{itemize}

\subsection{Anexo E - Ejemplos de Respuestas API}

\subsubsection{E.1 Endpoint: /temp}
\begin{verbatim}
GET http://[ALB-DNS]/temp?month=3&year=2017

Response (200 OK):
{
  "month": 3,
  "year": 2017,
  "temp": 17.06,
  "max_temp": 17.33,
  "last_updated": "2024-12-07T10:30:00Z"
}
\end{verbatim}

\subsubsection{E.2 Endpoint: /sd}
\begin{verbatim}
GET http://[ALB-DNS]/sd?month=3&year=2017

Response (200 OK):
{
  "month": 3,
  "year": 2017,
  "sd": 0.6254,
  "last_updated": "2024-12-07T10:30:00Z"
}
\end{verbatim}

\subsubsection{E.3 Endpoint: /maxdiff}
\begin{verbatim}
GET http://[ALB-DNS]/maxdiff?month=4&year=2017

Response (200 OK):
{
  "month": 4,
  "year": 2017,
  "maxdiff": 2.14,
  "max_temp": 19.47,
  "last_updated": "2024-12-07T10:30:00Z"
}
\end{verbatim}

\end{document}
